#快速排序
将一个数组的第一个数作为base，数组中大于base的放到右边，小于base的放到左边，
那么就会产生以base为界的两个单元：base左边的数组，包含base在内的右边的数组。
然后分别在左边和右边单元取第一个为base，又能分出4个子单元，直至一个某个子单元只有一个数位置，那么这一部分就结束了，
如果所有子单元都分割成只有一个了，即left=right，那么整个数组都排序好了。

那么怎么将一个数组（单元）中大于base的放到右边，小于base的放到左边呢？
首先，以第一个数作为base，left是数组头，right是数组尾，两个指针会朝中间移动。当两个指针不相遇，
先从右边开始，如果右边的大于base，那么说明正常，right会朝左边移动一位，继续寻找。直到right跟left相遇，或者遇到了右边的小于base的情况。
那么right位置的数，就会填到left位置上。就这样，一次right操作结束，接下来是left操作。
再从左边开始，如果左边的小于base，那么说明正常，left会朝右边移动一位，继续寻找。
由于上次right操作将小于base的数放到了left的位置，那么这次left位置的数必然是大于base的，所以第一次left操作是将；left向右移一位。
然后继续寻找，直到left跟right相遇，或者遇到了左边的大于base的情况。那么left位置的数，就会填到right位置上。就这样，一次left操作结束，接下来又是right操作。
两者反复操作，直至right跟left相遇后停止。
当我left与right碰头了，说明left在数组（单元）的中间，中间就应该放中间值，再将base交换给left的数，使得base的位置一直是中间的。
最后返回left位置，即数组的中间值位置。
随后的反复递归是避开i的，所以找到中间值，就相当于在数组中不断插入图钉，最后就在两个数中，有一个是图钉，那么另一个就孤零零地出现了！
